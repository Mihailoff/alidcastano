---
title: (why? :lisp)
---

I used to see Lisp code and wonder, how could anyone read that? But instead, what I should have asked is: why would anyone write that? Because, as I've come to learn, the programmers who read lisp do so for the same reason they write it: it's easy to think in. 

What does it mean to say a language is easy to think in? Well, I'd be more appropriate to say Lisp is *easier* to think in. In an ideal world we'd be able to telepathize with each other and with computers. But short of that, we need a language; a shared syntax to map our thoughts and others thoughts onto. Any language, compared to your direct thoughts, will always feel like it's in the way of what you want to express. So when I say Lisp is easier to think in I'm implying that, relative to other programming languages, it gets out of your way more; it gives more space to your thoughts.

It's ironic that this is the main appeal of Lisp. Its syntax is so unlike written English, which is what other programming languages try to model. So when you first read Lisp code and glance over a file filled with heavily indented, terse statements wrapped in parenthesis, all your mind can think is, "what the hell he this?" 
 

But you should cherish this initial reaction to Lisp, because it sits at the core of what makes it enlightening to learn: it doesn't model other languages for the sake of familiarity; instead, Lisp is the result of thinking from first principles. And I don't say that in the Elon Musk change-the-world cliche type of way. In fact, Lisp wasn't proposed as a programming language at first. When John McCarthy invented it in 1958, all he intended to do was define a formal model of computation for AI research. It wasn't until later that his student, Steve Russel, extended and implemented it as a programming language.

So what principles is Lisp based on?

I'd like to explore this question deductively, the same way I came to understand it. While learning Lisp, I'd wonder why its syntax had to be the way it is. The way you add two variables, for example, is `(+ x y)`, why can't it be `(x + y)` or even better `x + y`. Likewise, with conditional expressions, instead of `(and x y)` why can't it do `(x and y)` or even better `x and y`? 

These are in fact the two most prominent questions one has when learning Lisp:

1. Why are there so many parenthesis?

2. Why are operators out of their usual order?

As it turns out, the underlying answer to these two questions is the same.

### (why? :paren)

Let's start with parenthesis. Why must Lisp have so many if other programming languages manage with less?

Well, even that's not necessarily true. Other programming languages have the same amount of parenthesis, they're just situated differently.

Compare a conditional expression, one in Javascript (the language I was using before learning a Lisp) and the other in Clojure (the dialect of Lisp I chose to learn): 

```js
if (x) foo() 
else bar()
```

```clj
(if x (foo) (bar))
```

Both snippets have three pairs of parens. Except in Javascript, you need to know three arbitrary rules: after the `if` the conditional has to be wrapped in parens; to call a function you place parens right next to it; and, that the next `else` statement has to be in a new line (that is, unless you surround each expression block in curly brackets). Whereas in Clojure you need to know one rule, and it's not there just to get the compiler working, but fundamental to the entire language: you place parenthesis around expressions in the order you want them to evaluated.

You see, parenthesis are essential to Lisp for the same reason their essential to math: they emphasize the order of expressions. Would you rather memorize arbitrary rules like PEMDAS or have one visual indication for the order in which expressions should run? 

Now, my original example wasn't exactly fair. There's a shorthand for conditional expression in Javascript, so the above snippet could look like this:
```
condition ? foo() : bar()
```

Which leaves two parenthesis rather than three. But one more arbitrary rule to know for the sake of nicer syntax. Whereas Lisp changes ones conception of nice syntax. The same way vegetables taste better once you associate their taste with health, parenthesis read better once you associate their presence with simplicity.

### (why? '(first args))

Along with considering the order in which expressions are run, we also have to consider the order in which operations and their arguments are listed.

Compare an addition expression in Javascript versus Clojure. 

```js
x + y + z
```

```clj
(+ x y z)
```

For most developers the first example is clearer since the plus sign is in-between the variables, just like it'd be in regular math. Whereas in the second example the plus sign is first and the variables are after. That's a consistent pattern in Clojure and other Lisp dialects because putting the operation first allows you to pass multiple arguments to it; and that's something you expect to do with functions. Which is in fact what algebraic operations like `+` are in Clojure: functions. 

In any language there are special forms. A set of primitives that the compiler needs to know how to specifically interpret, and thus special rules that you as a developer have to know. What's special about Clojure is that the only forms that are special are the ones that can't help but be--and there are less than 20 of them; because Clojure, as a Lisp, builds on top of itself. 

The `if` statement, for example, is a special form because the compiler needs to be instructed to only conditionally evaluate an expression; the `when` statement, on the other hand, doesn't have to be because it can be built of top of `if`.

In Lisp, the special form that allows a program to build on top of itself is called a `macro`. One might ask, why doesn't my programming language have macros? But a better question would be: even if they did, how easy would they be to use? Because these two questions go hand in hand--most languages just aren't simple enough to build on top of themselves; so even if the functionality is exposed, it isn't used. Not even by the language designers themselves.

### (def simple)

What exactly do I mean when I say Lisp is simple? I mean simple in that it uses parenthesis to order expressions rather than arbitrary rules; and simple in that in a Lisp expression the operation comes first and the variables afterward, because the former needs to be evaluated first by the compiler and the rest are passed as arguments.

I mean simple in that I couldn't help but smile while learning Lisp. In the moments where I realized a programming language could be built out of a small set of rules, and that such rules could be so logically transparent. It's as if I was this a kid programmer with lots of questions of why things are the way they are and all my parent languages just said "Because," and then  Lisp came around and actually explained itself to me. The designers of my parent languages had their reasons too, sure; but they weren't evident to me while learning the language, whereas with Lisp they're fundamental to learning to use it well.

### (is simple :easy-thinking)

Is the simplicity of language alone a good enough measure to whether it's simple to think in?

There's actually one more contention developers usually have with Lisp that I've yet to address: why is the naming of the code so terse?

Let me ask you this first. In a Javascript for loop, why do developers name the looping variable `i`?

```
for (let i = 0; i < arr.length; i++) { /**/ }
```

When you read the above code you fill in the variable names yourself. You 
can infer that `i` is an integer and `arr` is an array. These abbreviations happen to be used across many languages, from C++ to Ruby to Javascript, so they're mutually understood amongst programmers. But there's also abbreviations that are idiomatic to certain styles of programming, and even to programming languages themselves.

Take this expression in Clojure: 

```
(assoc m k v)
```

To someone not familiar with Clojure or functional programming this code is terse; but if they are familiar with it, the code is succinct. `assoc` stands for `associate`, `m` for map, `k` for key, and `v` for value; the expression returns a new map with the newly associated key-value pairs. This functionality is well known amongst Clojurist, which is why they prefer these shorthands.

Our understand of code is based upon mutually understood words; but overtime, like an evolving language, we make it shorter, with slang. 

A programming language is standerdized computer slang. Once the core terminology is conceptualized, it becomes tedious to write it out completely. Not just because of extra typing, but because verbose language clutters thinking. Shorter syntax frees up space for more thought.

### (def succinct)

A statement is succinct if it can't be shortened without losing meaning. Likewise, a programming language is succinct if the program can't be shortered further without losing functionality.

A programming language should be as succinct as possible. Because the more code you can see at once, the more of your program you can [hold in your head](http://www.paulgraham.com/head.html). 

A succinct program, of course, isn't just made up of concise syntax, but powerful tools for abstraction. 

Lisp has more abbreviations than other programming languages because it encourages you to build your own language on top of it, so there's more meta languages you have to account for. Sitting at the top, in fact, is the abbreviations you use to model your application.

Succinctness, of course, makes it harder for another programmer to understand your code at first glance. But your program shouldn't be written for someone who'll superficially look at it, but for someone who'll take the time to understand it in its entirety. 

### (is (merge simple succinct) :easy-thinking)

As a goal, a programming language should be closer to thinking than writing; like the scribbles you write for yourself when trying to preserve a thought rather than the prose you write for others when trying to transmit an idea. 
Because what's wonderful about computers is that they'll speak any language you throw at them as long as the code compiles. So, runtime errors aside, the ultimate test of your code is the program itself. You don't have to convince programmers to understand your code if the merits of your program already do that for you.

So, above all, a programming language should make it easy to ideate. To scribble a thought down in code, expand on it, reword it, and refactor it.  
Repeating this process multiple times, not just until the program is in working form but until the idea itself is worth running.

And that, in turn, is why I'm gratified to be learning a Lisp dialect. The language is simple, so I can understand its ins-and-outs and build my own application language on top of it; and it's succinct, so I can hold the program in my head and manipulate it at will. After more than four years of programming, I finally feel like I can turn scribbles of code into eloquent programs.


